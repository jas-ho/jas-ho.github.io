---
layout: page
title: FVP Task Manager
---

<style>
  #taskList { list-style-type: none; padding: 0; margin-bottom: 60px; }
  #taskList li { margin-bottom: 10px; cursor: pointer; display: flex; align-items: center; padding: 5px; }
  .marked { font-weight: bold; }
  .completed { color: gray; text-decoration: line-through; }
  .last-marked { font-size: 1.2em; padding: 10px; border: 2px solid var(--link-color); border-radius: 5px; }
  .focused { background-color: var(--sidebar-bg); outline: 2px solid var(--link-color); }
  .task-text { flex-grow: 1; }
  .controls { display: flex; gap: 10px; }
  #task-controls {
    display: flex;
    align-items: center;
    gap: 10px;
    margin-top: 20px;
    flex-wrap: wrap;
  }
  #newTaskForm {
    display: flex;
    flex-grow: 1;
  }
  #taskInput {
    width: 100%;
    padding: 5px; /* Decreased padding for a sensible height */
    border: 2px solid var(--link-color);
    border-radius: 5px;
    font-size: 1em; /* Adjusted font size */
    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
    height: 2.5em; /* Match the height of the focus box */
  }
  #taskInput:focus {
    outline: none;
    border-color: var(--link-hover-color);
    box-shadow: 0 0 5px var(--link-hover-color);
  }
  button { background-color: var(--link-color); color: #fff; border: none; padding: 5px 10px; cursor: pointer; }
  button:hover { background-color: var(--link-hover-color); }
  .controls button { background: none; border: none; color: #888; font-size: 1.2em; cursor: pointer; padding: 5px; }
  .controls button:hover { color: var(--link-color); }
  .marked .controls .mark-btn { color: gold; }
  .completed .controls .complete-btn { color: green; }
  #fvp-container {
    transition: all 0.3s ease;
  }
  #fvp-container.fullscreen {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    z-index: 9999;
    background: var(--main-bg);
    padding: 20px;
    overflow-y: auto;
  }
  #fullscreen-toggle {
    position: fixed;
    top: 10px;
    right: 10px;
    z-index: 10000;
    background: none;
    border: none;
    color: #888;
    font-size: 1.2em;
    cursor: pointer;
    padding: 5px;
  }
  #fullscreen-toggle:hover {
    color: var(--link-color);
  }
  #fvp-container h1 {
    display: none;
    margin-top: 0;
  }
  #fvp-container.fullscreen h1 {
    display: block;
  }
  #fvp-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 20px;
    flex-wrap: nowrap;
  }
  #fvp-header h1 {
    margin: 0;
    font-size: 1.5em;
    flex-grow: 1;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }
  #keyboard-shortcuts {
    font-size: 0.9em;
    color: #888;
    margin-bottom: 20px;
  }
  #keyboard-shortcuts ul {
    list-style-type: none;
    padding: 0;
    display: flex;
    flex-wrap: wrap;
    gap: 10px;
  }
  #keyboard-shortcuts li {
    background-color: rgba(255, 255, 255, 0.05);
    padding: 5px 10px;
    border-radius: 4px;
  }
  #keyboard-shortcuts .key {
    font-weight: bold;
    color: var(--link-color);
  }
  #add-task-btn, #export-btn, #import-btn, #delete-all {
    background-color: transparent;
    color: #888; /* Grey icon color */
    border: none;
    padding: 5px 10px;
    cursor: pointer;
    font-size: 1.5em; /* Increase font size for icons */
    white-space: nowrap; /* Ensure no line breaks */
    transition: color 0.3s, background-color 0.3s;
  }
  #add-task-btn:hover, #delete-all:hover, #export-btn:hover, #import-btn:hover {
    color: var(--link-hover-color);
    background-color: rgba(255, 255, 255, 0.05); /* Slightly muted background on hover */
  }
  #add-task-btn::after, #delete-all::after, #export-btn::after, #import-btn::after {
    content: attr(title);
    display: block;
    font-size: 0.8em;
    color: #888;
    margin-top: 5px;
    opacity: 0;
    transition: opacity 0.3s;
  }
  #add-task-btn:hover::after, #delete-all:hover::after, #export-btn:hover::after, #import-btn:hover::after {
    opacity: 1;
  }
  #task-actions {
    margin-top: 20px; /* Add space between the new tasks input line and the task actions line */
  }
</style>

<div id="fvp-container">
  <button id="fullscreen-toggle" title="Enter Fullscreen">⛶</button>
  <div id="fvp-header">
    <h1>FVP Task Manager</h1>
  </div>
  <div id="keyboard-shortcuts">
    Keyboard shortcuts:
    <ul>
      <li><span class="key">↑↓</span> navigate</li>
      <li><span class="key">m</span> mark (★)</li>
      <li><span class="key">c</span> complete/reopen (✓)</li>
      <li><span class="key">n</span> new task</li>
      <li><span class="key">d</span> delete (×)</li>
      <li><span class="key">f</span> toggle fullscreen (⛶)</li>
    </ul>
  </div>
  <ul id="taskList" tabindex="0"></ul>
  <div id="task-controls">
    <form id="newTaskForm" onsubmit="addTask(event)">
      <input type="text" id="taskInput" placeholder="Enter a new task" required>
      <button type="submit" id="add-task-btn" title="Add Task"><i class="fas fa-plus"></i></button>
    </form>
  </div>
  <div id="task-actions" style="display: flex; justify-content: space-between; margin-top: 20px;">
    <button id="export-btn" title="Export Tasks"><i class="fas fa-download"></i></button>
    <button id="import-btn" title="Import Tasks"><i class="fas fa-upload"></i></button>
    <button id="delete-all" title="Delete All Tasks"><i class="fas fa-trash"></i></button>
    <input type="file" id="import-file" style="display: none;" accept=".json">
  </div>
</div>

{% raw %}
<script>
  let tasks = [];
  let focusedIndex = -1;

  // Function to save tasks to LocalStorage with error handling
  function saveTasksToLocalStorage(tasks) {
    try {
        const serializedTasks = JSON.stringify(tasks);
        localStorage.setItem('tasks', serializedTasks);
    } catch (e) {
        if (e.name === 'QuotaExceededError') {
            alert('Storage limit exceeded. Please delete some tasks.');
        } else {
            console.error('Failed to save tasks:', e);
        }
    }
  }

  // Function to load tasks from LocalStorage with validation
  function loadTasksFromLocalStorage() {
    try {
        const serializedTasks = localStorage.getItem('tasks');
        if (serializedTasks) {
            const tasks = JSON.parse(serializedTasks);
            if (Array.isArray(tasks)) {
                return tasks;
            }
        }
    } catch (e) {
        console.error('Failed to load tasks:', e);
    }
    return [];
  }

  function renderTasks() {
    const taskList = document.getElementById('taskList');
    taskList.innerHTML = '';
    let lastMarkedIndex = tasks.findLastIndex(task => task.marked && !task.completed);
    tasks.forEach((task, index) => {
      const li = document.createElement('li');
      li.innerHTML = `
        <span class="task-text">${task.text}</span>
        <div class="controls">
          <button class="mark-btn" onclick="toggleMark(${index})" title="Mark">★</button>
          <button class="complete-btn" onclick="toggleComplete(${index})" title="${task.completed ? 'Reopen' : 'Complete'}">✓</button>
          <button class="delete-btn" onclick="deleteTask(${index})" title="Delete">×</button>
        </div>
      `;
      li.setAttribute('tabindex', '0');
      li.onclick = () => setFocus(index);
      if (task.marked) li.classList.add('marked');
      if (task.completed) li.classList.add('completed');
      if (index === lastMarkedIndex) li.classList.add('last-marked');
      if (index === focusedIndex) li.classList.add('focused');
      taskList.appendChild(li);
    });

    // If the task list is empty, focus on the input box
    if (tasks.length === 0) {
      focusInputBox();
    }
  }

  function addTask(event) {
    event.preventDefault();
    const input = document.getElementById('taskInput');
    if (input.value) {
      tasks.push({ text: input.value, marked: false, completed: false });
      input.value = '';
      saveTasksToLocalStorage(tasks);
      renderTasks();
      // After adding a task, keep focus on the input box
      input.focus();
    }
  }

  function toggleMark(index) {
    tasks[index].marked = !tasks[index].marked;
    saveTasksToLocalStorage(tasks);
    renderTasks();
    // After rendering, we need to restore focus and update the focused item
    setFocus(index);
  }

  function toggleComplete(index) {
    tasks[index].completed = !tasks[index].completed;
    if (tasks[index].completed) {
      tasks[index].marked = false;
    }
    saveTasksToLocalStorage(tasks);
    renderTasks();
    // After rendering, restore focus to the same item
    setFocus(index);
  }

  function deleteTask(index) {
    tasks.splice(index, 1);
    saveTasksToLocalStorage(tasks);
    renderTasks();
    // After deletion, set focus to the previous item or the last item if we deleted the last one
    if (index > 0) {
      setFocus(index - 1);
    } else if (tasks.length > 0) {
      setFocus(0);
    } else {
      // If no tasks left, reset focusedIndex
      focusedIndex = -1;
    }
  }

  function setFocus(index) {
    focusedIndex = index;
    updateFocus();
  }

  function updateFocus() {
    const taskItems = document.querySelectorAll('#taskList li');
    const taskInput = document.getElementById('taskInput');
    taskItems.forEach(item => item.classList.remove('focused'));
    if (focusedIndex >= 0 && focusedIndex < taskItems.length) {
      taskItems[focusedIndex].classList.add('focused');
      taskItems[focusedIndex].focus();
    } else if (focusedIndex === -1 || focusedIndex >= taskItems.length) {
      // If we've gone past the last item or to the input box, focus the input box
      taskInput.focus();
      // Ensure no task has the 'focused' class
      taskItems.forEach(item => item.classList.remove('focused'));
    } else if (taskItems.length > 0) {
      // If focusedIndex is out of bounds but there are tasks, focus on the last one
      focusedIndex = taskItems.length - 1;
      taskItems[focusedIndex].classList.add('focused');
      taskItems[focusedIndex].focus();
    }
  }

  // Ensure the taskList can receive focus
  document.getElementById('taskList').setAttribute('tabindex', '0');

  function toggleFullscreen() {
    const container = document.getElementById('fvp-container');
    const fullscreenToggle = document.getElementById('fullscreen-toggle');
    container.classList.toggle('fullscreen');
    fullscreenToggle.textContent = container.classList.contains('fullscreen') ? '⮌' : '⛶';
    fullscreenToggle.title = container.classList.contains('fullscreen') ? 'Exit Fullscreen' : 'Enter Fullscreen';

    // Hide/show the sidebar and other page elements
    const sidebar = document.querySelector('.sidebar');
    const content = document.querySelector('.content');
    if (sidebar) sidebar.style.display = container.classList.contains('fullscreen') ? 'none' : '';
    if (content) content.style.width = container.classList.contains('fullscreen') ? '100%' : '';

    // Show/hide the inner title
    const innerTitle = container.querySelector('h1');
    if (innerTitle) innerTitle.style.display = container.classList.contains('fullscreen') ? 'block' : 'none';
  }

  document.getElementById('fullscreen-toggle').addEventListener('click', toggleFullscreen);

  function focusFirstTask() {
    if (tasks.length > 0) {
      focusedIndex = 0;
      updateFocus();
    }
  }

  function focusInputBox() {
    focusedIndex = -1;
    updateFocus();
  }

  document.addEventListener('keydown', function(e) {
    const taskList = document.getElementById('taskList');
    const taskInput = document.getElementById('taskInput');

    // Check if the active element is any input field
    if (document.activeElement.tagName === 'INPUT' || document.activeElement.tagName === 'TEXTAREA') {
      // Allow normal typing in input fields
      if (e.key === 'Escape') {
        focusFirstTask();
        e.preventDefault();
      } else if (e.key === 'ArrowUp' && tasks.length > 0) {
        focusedIndex = tasks.length - 1;
        updateFocus();
        e.preventDefault();
      }
      return;
    }

    if (e.key === 'f') {
      toggleFullscreen();
      e.preventDefault();
    } else if (e.key === 'Escape') {
      focusFirstTask();
      e.preventDefault();
    } else if (document.activeElement === taskList || document.activeElement.closest('#taskList')) {
      switch(e.key) {
        case 'ArrowUp':
          if (focusedIndex > 0) {
            focusedIndex--;
            updateFocus();
          } else if (focusedIndex === 0) {
            // If at the first item, wrap to the input box
            focusInputBox();
          }
          e.preventDefault();
          break;
        case 'ArrowDown':
          focusedIndex = Math.min(tasks.length, focusedIndex + 1);
          updateFocus();
          e.preventDefault();
          break;
        case 'm':
          if (focusedIndex !== -1) toggleMark(focusedIndex);
          break;
        case 'c':
          if (focusedIndex !== -1) toggleComplete(focusedIndex);
          break;
        case 'n':
          focusInputBox();
          e.preventDefault();
          break;
        case 'd':
          if (focusedIndex !== -1) {
            deleteTask(focusedIndex);
            e.stopPropagation();
            e.preventDefault();
          }
          break;
      }
    }
  });

  document.getElementById('delete-all').addEventListener('click', function() {
    if (confirm('Are you sure you want to delete all tasks?')) {
      tasks = [];
      saveTasksToLocalStorage(tasks);
      renderTasks();
      focusInputBox();
    }
  });

  document.getElementById('export-btn').addEventListener('click', function() {
    const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(tasks));
    const downloadAnchorNode = document.createElement('a');
    downloadAnchorNode.setAttribute("href", dataStr);
    downloadAnchorNode.setAttribute("download", "tasks.json");
    document.body.appendChild(downloadAnchorNode);
    downloadAnchorNode.click();
    downloadAnchorNode.remove();
  });

  document.getElementById('import-btn').addEventListener('click', function() {
    document.getElementById('import-file').click();
  });

  document.getElementById('import-file').addEventListener('change', function(event) {
    const file = event.target.files[0];
    if (file) {
      const reader = new FileReader();
      reader.onload = function(e) {
        try {
          const importedTasks = JSON.parse(e.target.result);
          if (Array.isArray(importedTasks)) {
            tasks = importedTasks;
            saveTasksToLocalStorage(tasks);
            renderTasks();
          } else {
            alert('Invalid file format.');
          }
        } catch (error) {
          alert('Error reading file.');
        }
      };
      reader.readAsText(file);
    }
  });

  // Load tasks when the page loads
  document.addEventListener('DOMContentLoaded', () => {
    tasks = loadTasksFromLocalStorage();
    renderTasks();
    document.getElementById('taskList').focus();
  });

  // Listen for changes to LocalStorage
  window.addEventListener('storage', (event) => {
    if (event.key === 'tasks') {
      tasks = loadTasksFromLocalStorage();
      renderTasks();
    }
  });
</script>
{% endraw %}
